---
title: "2-14: Debugging External Scripts (Unfinished)"
short: "2-14"
# special characters for highlighting code : «»
---

### This lesson is not complete

However, it is fit for student consumption.

## Purpose

-   Use browser() to debug external script

-   Downloading package script and debugging those

## Material

The [script for the lesson is here](../scripts/2-14_DebugExternalScripts.R)

A [second script that contains a function to debug](../scripts/2-14_myFunctions.R)

The [data used for the lesson](../data/Lansing2016Noaa-3.csv) is here

## External Scripts in R

In R, we run external script files using `source()`. Ideally, external scripts should contain only function definitions. This is because any code that exists outside of a function is executed immediately when the file is sourced, which can lead to unintended side effects such as modifying objects in the Environment, changing global options, or producing unexpected output. By placing all executable code inside functions, we force the user to be explicit about when and how that code is run. In addition, functions are reusable, testable, and easier to debug, which improves code organization, readability, and long-term maintainability.

## Debugging Scripts

In the last lesson, we used breakpoints in RStudio to debug our main script. Breakpoints work by pausing execution and giving you an interactive environment to step through the script and inspect objects at that point in time. This method works very well when debugging your main script.

 

However, breakpoints do not work reliably in external scripts called using `source()`. For external scripts, we instead use the R command `browser()` to pause execution and enter a debugging environment.

### Debugging External Scripts with `browser()`

The `browser()` function can be placed directly inside an external script or function. When R reaches `browser()`, it pauses execution and opens an interactive debugging session, similar to a breakpoint. Unlike RStudio breakpoints, `browser()` works consistently inside sourced scripts and functions.

 

The main drawback of `browser()` is that it must be added and removed from the code manually, whereas breakpoints can be turned on and off using the RStudio interface. For this reason, breakpoints are best for debugging your main script, and `browser()` is best for debugging external scripts and functions.

![browser() in the Help tab](images/R-2-15_Browser_Help.png){#fig-browser-help .fs}

## Adding browser() to function  

When you add browser() to a function, this tells R to pause the execution and put the scritpt in debug mode. We will add browser() rightbefore the for loop in the high_and_low() function. When the high_and_low function is called the RStudio tab will switch to the 2-14_function.R script and

![Debug mode inside a function](images/R-2-14_DebugMode.png){#fig-debugMode .fs}

### Components of debug mode

Most of @fig-debugMode should look familiar from the last lesson. There is

-   A green arrow will appear at the code line the script is paused at. The green arrow shows you the line that will be executed next

-   Debug controls will appear in the ***Console*** tab

-   The ***Console*** will indicate it is in browse mode  with `Browse[1]>`

-   A traceback window will appear at the bottom of the ***Environment*** tab

One important difference in highlighted in the ***Environment*** tab, where it says ***high_and_low***. This means that the ***Environment*** is giving you the view from the function high_and_low – so you will only see the variables that are known to the function.

 

When you are in you main script, you will see the ***Global Environment*** view – in fact, you can switch if you click the down arrow.

### The function Environment

Arguments in a function are essentially variables that the function can see that are set by the caller. In this case: high, low, and dates are variables set by the caller and inside the Environment of the function.

 

The other variables in the function (highest_high, highest_low) were declared before ***browser()*** so those lines how already been executed.

### Debugging controls

All of the debugging control work the same as in last lesson.

-   ***Next*** will execute the next command and move the green arrow

-   ***Step In*** will move into a function (if there is one)

    -    If there is no function, ***Step In*** acts like ***Next***

-   ***Step Out*** will complete the execution of the function

-   ***Continue*** will unpause script execution until the next ***browser()***

    -   If there are no more ***browser()***, then ***Continue*** complete the function

-   ***Stop*** will quit the script – no more code gets executed.

### conditional browser()

It is often useful to put a conditional ***browser()*** within a ***for*** loop, especially if you for loop is cycling many times. The ***for*** loop already has for conditional statement, each checking the extreme value against the current value. You could put a browser() there if you want to see each time a value was changed.

``` r
    else if(highs[i] < lowest_high$temp)
    { 
      browser()
      lowest_high$temp = highs[i];
      lowest_high$date = dates[i];
    }
```

You could add a condition that pauses on a certain cycle:

``` r
  for(i in 2:length(highs))
  { 
    if(i == 10) browser()  # brackets are not needed here
    
    if(highs[i] > highest_high$temp)
    {
      highest_high$temp = highs[i];
      highest_high$date = dates[i];
    }
    ...    
```

or based on a variable

``` r
   for(i in 2:length(highs))
  { 
    if(highs[i] > 90) browser()  # brackets are not needed here
    
    if(highs[i] > highest_high$temp)
    {
      highest_high$temp = highs[i];
      highest_high$date = dates[i];
    }
    ...
```

### browser() is only for debugging

Don't forget to remove them

## Functions from packages

R Packages are essentially script files with function in them. However, you cannot use breakpoints or ***browser()*** to debug them because you do not have access to the script file. So we are going to download packages script to your computer where they can be seen and used just like any other external script.

 

We are going to download the pracma package to

The steps are:

-   download the package (in this case, pracma)

-   unzip the package

-   install pkgload library

-   load downloaded library

-   now you can debug scripts in the library just like before

### Downloading package script

The command to download the package to your computer is:

``` r
download.packages("pracma", destdir = "C:/Users/Charlie/Desktop", type = "source")
```

You do need to change the ***destdir*** to a legitimate folder on your computer. [Note: On Windows, `destdir = "~"` will likely download to your Document directory.]{.note}

### Unzipping package

The package will be download as a \*.gz file. These files can be unzipped just like a \*.zip file. I save the ***pracma*** folder, to the ***scripts*** folder in my project

### Install pkgload

pkgload is an R package that allows you to load a local library folder, which pracma now is.

``` r
install.packages("pkgload")
```

### load the local library

You need to know where your library folder is. I saved the folder within my project folder:

``` r
pkgload::load_all("scripts/pracma")
```

## Debugging package script

All the script files are inside the R folder. When you load the package, you are loading all of the function from all of these script files.

 

You can now open the script file in RStudio and edit it – in this case I added ***browser()*** to line 11 of the ***isprime()*** function in the ***isprime.R*** script:

![Debugging a function from a package](images/R-2-14_DebugPAckage.png){#fig-debugpackage .fs}

### Debugging

Now you can call ***isprime()*** from your main script and ***browser()*** will put the function in debug mode:

``` r
isprime(c(1,2,4,71,88,2131, 3287, 7819));
```

Debug mode will work exactly as is did before for your own external scripts.

## Application

Why should external scripts only contain functions?

Create a function that returns a named list with attributes

## Extension: Next in advanced class

-   trace() to inject code

-   functional programming

-   object-oriented programming (S3 vs S7 objects)

-   Environment and variable scope

    -   why if-else works in f() and for loops

-   commands and subcommands in R { }

-   Rcpp

## Extension: Different approaches to breakpoints

### source() outside script first, add breakpoints

-   do not source() or rm(list=lm()) in main script

-   only works when Run

### source() from main script, add breakpoints, run function

-   do not source() or rm(list=lm()) in main script

-   only works when Run

-   does it work if you put the bp on the function??

    -   No, because source()

### add breakpoints, debugSource() from main script, run function

-   do not source() or rm(list=lm()) in main script

-   only works when Run

-   does it work if you put the bp on the function??

    -   no, it gets really weird!

### Debugging 4 scenarios

1\) Within main (sourced) script

-   breakpoint

-   browser

    -   but, browser() needs to be encapsulated between { }

2\) Function outside your main (sourced) script

-   browser() : inconsistent in main script, works in functions

-   source functions script from main, add breakpoint, Run function from main

    -   external breakpoint are broken when file is sourced

3\) External script (not a function script) – No!

-   done rarely and bad practice, and a pain to debug, so probably not going to teach

4\) Function in package

-   download package to computer

-   load with pkgload

-   can use browser() as if this were scenario 2

## Extension: Using breakpoints in external scripts

\<often need to clear all bp\>

note: bp works under some circumstances in external script

source main, sources external: no

source main, debugSource external: yes

source external, put in breakpoint, run from main: yes

put in breakpoint, source external, run from main: yes
