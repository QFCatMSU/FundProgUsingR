---
title: "2-12: Lists"
short: "2-12"
# special characters for highlighting code : Â«Â»
---

### To-do

-   expand lesson to include reading/writing Lists to RData file

## Purpose

-   Creating you own List

-   Subsetting a List

-   Reading a List return from plots and models

## Script for this lesson

The [script for the lesson is here](../scripts/2-12_Lists_new.R)

The [data used for this lesson and the application](../data/Lansing2016Noaa.csv) is here

## Objects in R

As mentioned in last lesson, there are 2 types of objects (i.e., variables) in R:

-   Atomic vector (often just called vectors): objects that hold values of the same type (e.g., numeric, string, logical)

-   Lists: objects that hold other objects (including more Lists)

    Â 

The relationship between Atomic Vectors and Lists is analogous to the relationship between folders and files on your computer.Â  Files, like atomic vector, hold information, or data.Â  Folders, like Lists, are containers for other folders and files.

Â 

Last lesson we talked mostly about atomic vectors. This lesson we will talk mostly about Lists. As you will see in this lesson, Lists create a tree-like structure for your data.Â  At the end of the tree is the Atomic Vectors

## Lists

A List is an object that holds other (usually related) objects. When you create a plot or perform a statistical test, the results are often stored as Lists, as we will see later in the lesson.

Â 

We will create our own List with three objects in it.

Â 

The three objects will be:

-   a character vector called ***someAnimals***

-   a 2x3 matrix consisting of a sequence of six numbers called ***someNumbers***

-   the ***weatherData*** dataframe from previous lessons

``` r
someAnimals = c("llama", "guanaco", "alpaca", "goat");
someNumbers = matrix(nrow=2, ncol=3, seq(from=30, to=4, length.out=6))
weatherData = read.csv(file="data/Lansing2016NOAA.csv");
```

### Lists in the Environment tab

Notice that, in the Environment, ***weatherData*** has an arrow to expand it whereas ***someAnimals*** and ***someNumbers*** contains all of their information in one line.Â  It is this expand arrow that indicates ***weatherData*** is a List, whereas ***someAnimals*** and ***SomeNumbers*** are atomic vectors.Â  ***weatherData*** is a data frame, which is List where all the objects inside are vectors of the same length:

![The expand arrow in the Environment indicates that the object is a List (i.e., holds other objects)](images/R-2-11-ListExpandArrow.png){#fig-list_expand_env .fs}

### Creating the new List

We can create a List with the three objects above using the ***list()*** function:

``` r
listAtOnce = list(someAnimals, someNumbers, weatherData);
```

This will add ***listAtOnce*** to the ***Environment***.Â  From there we double-click on it to see it in a ***Viewer*** tab.Â  The ***Viewer*** tab offers a more helpful and informative view of the List.

Â 

A couple things to notice about ***listAtOnce*** in the ***Viewer*** tab:

-   The objects inside the List do not have names -- instead they only have numbers.Â  [Objects do not retain their names when put in to a List.]{.hl}

-   The third object **\[\[3\]\]**, the dataframe, has an expand arrow.Â  The arrow indicates that this object is also a List -- **\[\[1\]\]** and **\[\[2\]\]** are atomic vectors.

Â 

![The List inside a Viewer tab](images/R-2-11-ListInViewer.png){#fig-list_viewer .fs}

[Note: When looking at the List in the Viewer, the objects with expand arrows are functionally similar to folders, those without arrows are functionally similar to files]{.note}

### Including names for the objects

If we want the objects inside the List to have names, then we have to specify the names while creating the List.Â  You do that by setting a name equal to the object when calling ***list()***:

``` r
  listAtOnce2 = list(animals = someAnimals,
                     numbers = someNumbers, 
                     weather = weatherData);
```

This makes ***animals***, ***numbers***, and ***weather*** the names of the objects ***someAnimal***, ***someNumbers***, and **weatherData** [inside the List]{.hl}.Â  You can choose any name, including the same as the original objects:

![Adding names to the objects inside the List](images/R-2-11-ListWithNames.png){#fig-add_names_list .fs}

[Note: names inside Lists, like variables, should follow programming naming conventions -- but this is not enforced in R.]{.note}

## Creating a dynamic List

In the previous example, all the objects put in the List were put in at once.Â  What often happens is that data is generated and gets dynamically added to a List, so the objects are put in the List separately.Â  We are going to create a List equivalent to ***listAtOnce*** except the three object will be put in one at a time.

Â 

First we create a List with nothing in it (i.e., an empty list):

``` r
listDynamic = list();
```

``` {.r tab="Environment"}
listDynamic:  List of 0
```

### Appending to the List

Then add the object ***someAnimals*** to the List.Â 

``` r
listDynamic2  = append(listDynamic, someAnimals); 
```

Somewhat unintuitively, ***append()*** does not append the object ***someAnimals*** to the List.Â  Instead, ***append()*** appends each value within ***someAnimals*** to the List -- making each value a separate object.Â  Now you have a List with 4 string vectors (each with 1 value) .... this is not what we want.

![Appending an object one value at a time...](images/R-2-11-IncorrectAppend.png){#fig-append_object .fs}

### Appending whole objects

We want is to append ***someAnimals*** to the List as vector and, to do this, we need to (unintuitively) wrap ***someAnimals*** inside its own List:

``` r
listDynamic3 = append(listDynamic, list(someAnimals));
```

And, if we want the object to have a name inside the List, then we need to provide the name -- just like @fig-add_names_list :

``` r
listDynamic4 = append(listDynamic, list(animal = someAnimals));
```

***listDynamic3*** and ***listDynamic4*** both now have a vector with four character values, the latter has that vector named:

![Lists with appended objects](images/R-2-11-AppendedLists.png){#fig-list_appended .fs}

### Appending multiple objects

We will now append ***someNumber*** and ***weatherData*** using ***append()***:

``` r
listDynamic5 = append(listDynamic4, list(numbers=someNumbers));
listDynamic5 = append(listDynamic5, list(weather=weatherData));
```

And see that ***listDynamic5*** is a List with three objects in it: ***animals***, ***numbers***, and ***weather*** -- just like ***listAtOnce2*** (@fig-add_names_list).

![Lists after the three objects were appended and named](images/R-2-11-FinishedAppendedList.png){#fig-three_objects_appended .fs}

## Subsetting within a List

The RStudio ***Viewer*** tab for Lists has a nice feature where it will shows you how to subset an object inside a List when you click on it.Â  In ***listDynamic5*** List, when you click on ***avgTemp*** in the ***weather*** dataframe -- and at the bottom of the tab, RStudio shows the code to subset ***avgTemp***:

``` r
listDynamic5[["weather"]][["avgTemp"]]
```

If you click the document icon with an arrow on the right-side, RStudio will put the above code in the ***Console*** where you click ***Enter*** to execute it:

![Opening an object within a List from the Viewer tab](images/R-2-11-SubsetInViewer.png){#fig-viewer_to_Console .fs}

### Subsetting with \$ and \[\[ \]\]

Every object in the List Viewer with a value under ***Name*** in @fig-viewer_to_Console can be accessed with both the **\$** and **\[\[ \]\]** subset operators -- RStudio always uses **\[\[ \]\]**.

Â 

Here are two ways to subset the ***animal*** object inside ***listDynamic5*** -- the results are saved to ***anim1*** and ***anim2***:

``` r
anim1 = listDynamic5[["animal"]];
anim2 = listDynamic5$animal;
```

The ***string*** (chr) vectors ***anim1*** and ***anim2*** have the same values as the original ***someAnimals*** vector:

``` {.r tab="Environment"}
anim1:       chr [1:4] "llama" "guanaco" ...
anim2:       chr [1:4] "llama" "guanaco" ...
someAnimals: chr [1:4] "llama" "guanaco" ...
```

Here are three ways to subset the ***dewPoint*** vector within ***weather***, which is within ***listDynamic5***:Â 

``` r
dewPoint1 = listDynamic5$weather$dewPoint;
dewPoint2 = listDynamic5[["weather"]][["dewPoint"]];
dewPoint3 = listDynamic5[["weather"]]$dewPoint;
```

Again, all three saved values are identical to the original ***weatherData\$dewPoint***:

``` {.r ta="Environment"}
dewPoint1:       20 22 20 13 10 16 ...
dewPoint2:       20 22 20 13 10 16 ...
dewPoint3:       20 22 20 13 10 16 ...
ðŸžƒ weatherData:  366 obs. of 23 variables
    $ dewPoint:    20 22 20 13 10 16...
```

**\$** and **\[\[ \]\]** are equivalent operators when you are working with named objects within a List.Â  **\$** is more convenient to use because it involves less typing and RStudio will give you suggestions.

### Numeric subsetting (only with \[\[ \]\])

Objects within a Lists can also be accessed by their numeric order using **\[\[ \]\]**:

``` r
anim3 = listDynamic5[[1]];
dewPoint4 = listDynamic5[[3]][[7]];
```

But, you cannot use the **\$** operator to subset by number:

``` r
# anim3 = listDynamic5$1;   # will cause an error
```

So, if the object inside a List does not have a name, as in ***listAtOnce*** (@fig-list_viewer), then you have to use **\[\[ \]\]** to subset the unnamed object by numeric placement.

### The \[ \] subset operator

You can use **\[ \]** to subset the List, but instead of getting the object, you will get a List with the object in it:

``` r
anim4 = listDynamic5["animal"];
```

In the ***Environment***, we can see thatÂ  ***anim1***, ***anim2***, and ***anim3*** (subsetted with either **\[\[ \]\]** or **\$**) are all character vectors with 4 values.Â  But, ***anim4*** (subsetted with **\[ \]**) is a List with a character vector that has 4 values:

::: {#fig-double_single_brackets}
``` {.r tab="Environment"}
anim1:   chr [1:4] "llama" "guanaco" ...
anim2:   chr [1:4] "llama" "guanaco" ...
anim3:   chr [1:4] "llama" "guanaco" ...

ðŸžƒ anim4:   List of 1
   $ animal: chr [1:4] "llama" "guanaco" ...
```

The difference between using \[\[ \]\] or \$ vs \[ \] for subsetting objects within a List
:::

This is not very useful so **\[ \]** is rarely used to subset a List.

## Returned List from functions

We are going to move from creating our own Lists to looking at Lists that are returned when you call certain functions, specifically ***lm()***.

Â 

When we create a linear regression model of humidity vs temperature using ***lm()***, the results are saved to a list, in this case named ***model1***:

``` r
Â«model1Â» = lm(formula=weatherData$avgTemp~weatherData$relHum);
```

And then look at a summary of the model using ***print(summary(model1))***:

::: {#fig-summary_linear_reg}
``` r
>   print(summary(model1));
Call:
lm(formula = weatherData$avgTemp ~ weatherData$relHum)
Residuals:
    Min      1Q  Median      3Q     Max 
-44.213 -14.424  -0.213  15.479  36.461 
Coefficients:
                   Estimate Std. Error t value Pr(>|t|)    
(Intercept)        77.27006    6.07644  12.716  < 2e-16 ***
weatherData$relHum -0.38696    0.08722  -4.437 1.21e-05 ***
---
Signif. codes:  
0 â€˜***â€™ 0.001 â€˜**â€™ 0.01 â€˜*â€™ 0.05 â€˜.â€™ 0.1 â€˜ â€™ 1
Residual standard error: 18.59 on 364 degrees of freedom
Multiple R-squared:  0.0513,    Adjusted R-squared:  0.04869 
F-statistic: 19.68 on 1 and 364 DF,  p-value: 1.213e-05
```

Summary of a model of a linear regression
:::

### The returned List: linear model

***model1*** is a List object and the information for the linear model is stored in the List:

![The List returned from a lm() call](images/R-2-11-modelList.png){#fig-returned_list .fs}

### Subsetting the linear model List

***model1*** has information that is inside the summary, for instance the estimate for the intercept is at:

``` {.r tab="Console"}
> model1$coefficients["(Intercept)"]
(Intercept) 
   77.27006 
```

[Note: **(Intercept)** does not follow good programming naming practices!]{.note}

Â 

We need to use **\[ \]** to subset ***coefficients*** because ***coefficients*** is an atomic vector.Â  [Note: Subsetting operators are a bit inconsistent in R.]{.note}

Â 

We can also subset the first ten ***residuals*** from ***model1***:

``` {.r tab="Console"}
> model1$residuals[1:10]
          1           2           3           4           5 
-21.8609230 -17.7957344 -22.7305458 -30.0869984 -32.5696589 
          6           7           8           9          10 
-24.8914326 -19.4392818 -12.3130738  -0.1216773 -20.0869984 
```

Or, subset every twentieth value in ***fitted.values***:

``` {.r tab="Console"}
> model1$fitted.values[seq(from=1, to=366, by=20)]
       1       21       41       61       81      101      121      141 
47.86092 45.92611 52.11751 44.76522 57.53498 46.31307 49.02181 57.92194 
     161      181      201      221      241      261      281      301 
54.43928 57.53498 54.82624 55.21321 47.47396 45.15219 50.56966 43.60434 
     321      341      361 
48.24789 46.31307 46.70004 
```

There are also a lot of other, more obscure, values in the List object which we will not go through.Â  The point is that there is a lot of information inside the List and that information can be extracted using subset operators.

### New variables types

If you look through ***model1***, you will find three new variable types: ***language***, ***symbol***, and ***formula***.Â  These variables types are used by R programmers to store the code that created the List -- this is not something you will need to deal with at this point.

![Some of the less common variable types appear in this List](images/R-2-11-OtherVariableTypes.png){#fig-less_common_var_types .fs}

## Application

A\) Why is it better to subset objects by name instead of position numbers?

-   Save the answer to a 1-character vector

-   Add the ***name*** "comment" to the value

    Â 

B\) Using ***weatherData***, create a linear model of dewpoint vs temperature

-   Save the model to a List named ***linearModel1***

    Â 

C\) Using only values in ***linearModel1***, find and save:

-   the slope and the intercept

-   the last 10 effects values

-   the first 10 values from the original temperature vector

-   the most extreme residual value (i.e., furthest from 0 -- could be positive or negative)

Â 

D\) Create one List named ***app2_12_List*** that contains the objects from parts A, B, and C in this application

Â 

E\) Write the List to an RData file named ***app2-12List.RData*** in the ***data*** folder.

{{< include ../assets/_AppInstructions.qmd >}}
