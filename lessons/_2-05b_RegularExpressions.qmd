---
title: "2-05b: Regular Expressions (Unfinished)"
short: "2-05b"
# special characters for highlighting code : «»
---

### Regex

-   AI statement... [awkwardness]{.hl}of RegEx

    -   clear way to do RegEx but it can be tricky to keep track of

-   Use baby names file

-   Find substring anywhere within string

    -   How many Rebeccas are there

-   at start of string (\^), at end of string (\$)

    -   names starting with

    -   names ending with

-   escape string (\\\\) – create a vector in script that has \^, \$, \\

    -   R sees "\\\\" as one backslash and send that to regex

    -   let's say you want to find \^ or \$ within a string

    -   EX: Give a vector with multiple strings with \$ (you don't want \$ to mean end)

    -   And if you want to find a backslash...

-   one character options (multiple, range, all):

    -   \[Aa\] – (pick one from)one character chosen from this list

        -   difference between A\|B and \[AB\]

        -   special characters lose meaning in square brackets

    -   \[abcd\]

        -   Mari, Mary...

    -   \[\^abcd\]: now it means negation of everything in bracket

        -   names without the letters "a" or "e"

    -   any letter: \[a-zA-Z\]

    -   any number: \[0-9\]

    -   any letter or number: \[a-zA-Z0-9\]

    -   any char: . (every character except \\n)

-   How many characters:

    -   { min, max }

    -   Extension: some min, max have shortcuts

-   Grouping of characters

    -   (ab){3} matches ababab

    -   ab{3} or a(b){3} matches abbb

        -   there are reasons to do the latter (not covered in this lesson)

## Purpose

-   finding complex string pattern within a vector

## Script and data for this lesson

The script for this lesson [can be downloaded here](../scripts/2-05b_RegularExpressions.R)

The data for this lesson [can be downloaded here](../data/filenames.csv)

Regex cheat sheet (very useful):

<https://github.com/rstudio/cheatsheets/blob/main/regex.pdf>

-   click Download Raw button

## What is Regex

In the last lesson, we used Regular Expressions (RegEx) to find substrings within a string. However, the real power of RegEx is that it allows you to identify complex patterns, letting you search based on how a string is structured rather than the exact text it contains.

 

The data file for this lesson a made up list of filenames. Let's save the filenames column to a vector:

``` r
file_names = read.csv(file="data/filenames.csv")[[1]];
```

## Finding substrings within strings

Just like last lesson, we can find values that contain a specific string. Let's look for names that contain "reading":

``` r
reading = read.csv(file="data/Popular_Baby_Names.csv");
```

reading has 12 value, so there are 12 filenames with the substring reading in them. We can view the 12 filenames

``` r
reading_names = file_names[reading]
```

``` {.r tab="Console"}
> reading_names
 [1] "sensor_x103_reading_2019-05-22.dat"        
 [2] "sensor_z13_reading_20210711(obs).dat"      
 [3] "sensor_x11_reading_20191130.dat"           
 [4] "sensor_x13_reading_20200808(obs).dat"      
 [5] "sensor_z12_reading_20211225.dat"           
 [6] "sensor_y13_reading_20220917(obs).dat"      
 [7] "sensor_z10_reading_20181111!.dat"          
 [8] "sensor_z11_data_reading_final_20210922.dat"
 [9] "sensor_y10_reading_20220716.dat"           
[10] "sensor_x142_data_reading_20211212.dat"     
[11] "sensor_y14_reading_20211230(obs).dat"      
[12] "sensor_z145_reading_20210509.dat"   
```

### Multiple substrings

We can look for multiple substrings using the OR ( \| ) operator. The following code will look for any filename that has the substring "reading" or "status":

``` r
reading_status = grep(file_names, pattern="reading|status")
reading_status_names = file_names[reading_status]
```

There are now 19 values, meaning that 7 file names had "status" as a substring.

## Starts and ends with

Finding substrings within a string is the most basic thing RegEx can do. We are going to step up in difficulty and check for something at the beginning and the end of a string. In RegEx, ( \^ ) indicates the beginning of a string and ( \$ ) indicates the end of a string.

 

So, to say "starts with plot" as opposed to "contains plot", we put \^ at the beginning to indicate that the string needs to begin with the pattern:

``` r
start_station = grep(file_names, pattern="^station")
start_station_names = file_names[start_station]
```

And there is the equivalent end indicator ( \$ )

``` r
end_txt = grep("txt$", file_names)
end_txt_names = file_names[end_txt]
```

### Both start and ends

This is the first example where we are really using the pattern recnition features in RegEx. We cannot just combine the two examples above start_end_bad = grep(file_names, pattern="\^stationtxt\$")to find names that start with "station" and end with "txt".

``` r
start_end_bad = grep(file_names, pattern="^stationtxt$")
```

This is because we need to describe what is in between station and txt. If we do not care what is in between, we can say in regex: any number of any charatcter .{0,}

``` r
start_end1 = grep(file_names, pattern="^station.{0,}txt$")
```

[note: .\* is a shortcut for .{0,} but believe it is important to understand what {0,} does, which we will cover in this lesson, before using the shortcuts.]{.note}

If we want to find something in the middle, like "B3", we can say this:

``` r
start_end1 = grep(file_names, pattern="^station.{0,}B3.{0,}txt$")
```

BAsically, the patter says:

-    starts with "station

-   has any number of any character

-    has B3

-   has any number of characters

-   ends with txt

And only one filename meets this pattern:

\< \>

## Handling special character

REgex uses special characters to define patterns. Spercial character are characters that have meaning beyond the character itself. The special characters used in the previous section we3re \^, \$, ., {, and }. We are going to focus on the first three.

 

If you want to find these checracters within a string then you have to tell RegEx that you actually want the character,not the special feature of the character. To do this we [escape ]{.hl}the special character by putting two backslashes if front of it

If we want to find any filename that has a \^ in it:

``` r
has_caret = grep(file_names, pattern="\^$") 
has_caret_names = grep(file_names, pattern="\^")
```

## Range of charcatres

\<have\>

## Repeating chracters

\<8 numbers in a row

## Regex only see characters

\<keep for application... have student regex weatherdata\>

 

When you have regex search through numeric values, regex does not see numbers, regex see characters. So 127 is the character 1 followed by 2, followed by 7.

 

Let's take the temperature departture column from weatherData. What this code does is look for any string that:

-   starts with 0 or 1 minus sign (\^\\\\-{0,1})

    -   the \\\\ is needed because - has a function in RegEx, so we tell Regex that we want the character "-", not the function of -.

-   The optional minus sign is followed by a number between 2 and 9

-   The number between 2 and 9 is followed by any number

``` r
high_temp_dept = grep("^\\-{0,1}[2-9][0-9]", weatherData$tempDept);
```

So high_temp_dept is an index of any number \>= 20 or \<=-20

\<Make escaping the backslashes an Extension because of the unique nature of the backslash in R\>

[note: I added the argument ignore.case = TRUE because the dataframe switches between uppercase and lowercase, whereas I do not care what case the name is in.]{.note}

Challenge: Use ***grep()*** on the ***precip*** column in ***weatherType*** to ([note: **precip** is a string column]{.note}):

1.  find all precipitation values greater than or equal to 1.0 (hint: what is a unique substring for values \>= 1)

2.  find all precipitation values greater than or equal to 0.8

3.  find all days that have precipitation values greater than 0.8 and have maximum temperatures between 70-80

    -   use ***which()*** to find the temperatures

{{< include ../assets/_AppInstructions.qmd >}}
